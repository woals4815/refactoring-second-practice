# ch.06 기본적인 리팩터링

추출은 이름 짓기.

함수 선언 바꾸기: 함수 이름을 변경할 때, 함수의 인수를 추가, 제거

변수 이름 바꾸기: 위의 행위 대상이 변수일 때
|
|__ 변수 캡슐화 하기와 관련 깊음
|
|__ 매개변수 객체 만들기

함수를 만들고 고수준 모듈로 묶는다
|
|__ 여러 함수를 클래스로 묶기: 함수들이 사용하는 데이터도 클래스로 함께 묶음
|
|__ 여러 함수를 변환 함수로 묶기: 읽기전용 데이터를 다룰 때 좋음

묶은 모듈들의 작업 처리과정을 명확한 단게로 구분 짓는 단계 쪼개기 적용

## 6.1 함수 추출하기

process
- 1. 함수를 새로 만들고 목적을 잘 드러내게 naming(have to focus on what to do, not how to do)
- 2. 추출한 코드를 원본 함수에서 복사해 새 함수에 붙여넣는다.
- 3. 추출한 코드 중 원본 함수의 지역변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는 지 검사. 있다면 매개변수로 전달
|
|__추출한 코드에서만 사용하는 변수가 추출함수 밖에서 선언됐다면 추출 함수 내부로 선언하도록 수정한다. 
|__추출한 코드 안에서 값이 바뀌는 변수 중에서 값으로 전달되는 것들 주의해서 처리. 이런건 계산을 하는 질의 함수로 취급해서 그 결과를 해당 변수에 대입

- 4. 변수를 다 처리했다면 컴파일
- 5. 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다
- 6. 테스트
- 7. 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는 지 살핀다. 있으면 방금 추출한 새 함수를 호출하도록 바꿀지 검토(인라인 코드를 함수 호출로 바꾸기- 8.5)



## 6.2 함수 인라인 하기

process
- 1. 다형 메서드인지 확인
|__ 서브클래스에서 오버라이드 하는 메서드는 인라인 하면 안됨

- 2. 인라인할 함수를 호출하는 곳을 모두 찾는다/
- 3. 각 호출문을 함수 본문으로 교체한다.
- 4. 하나씩 교체할 때마다 테스트한다.
- 5. 함수 정의를 삭제한다.


## 6.3 변수 추출하기

process

- 1. 추출하려는 표현식에 부작용은 없는 지 확인
- 2. 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입
- 3. 원본표현식을 새로만든 변수로 교체한다.
- 4. 테스트
- 5. 표현식을 여러 곳에서 사용한다면 각각을 새로 만든 변수로 교체한다. 하나 교체할 때마다 테스트

## 6.4 변수 인라인 하기

background: 변수는 함수 속 표현식을 가리키는 이름으로 쓰인다. 하지만 그 이름이 표현식과 다를 바 없을 대도 있다. 이 변수가 주변 코드를 리팩토링할 때 방해가 되기도 한다. 이럴 때는 그 변수를 인라인하는 것이 좋음

process

- 1. 대입문의 우변(expression)에서 부작용이 생기지는 않는 지 확인
- 2. 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트
|__ effect: 변수에 값이 단 한번만 대입되는 지 확인할 수 있다
- 3. 이 변수를 가장 처음 사용하는 코드를 찾아서 대입문 우변의 코드로 바꾼다
- 4. 테스트
- 5. 변수를 사용하는 부분을 모두 교체할 때까지 이 과정을 반복한다.
- 6. 변수 선언문과 대입문을 지운다
- 7. 테스트


## 6.5 함수 선언 바꾸기

background: 이름이 좋으면 함수의 구현 코드를 살펴볼 필요없이 호출문만 보고도 무슨 일을 하는지 파악할 수 있음. 매개변수 또한 마찬가지다. 이렇게 하면 활용 범위가 넓어질 뿐만 아니라 다른 모듈과의 coupling을 제거할 수도 있다. 

first process

- 1. 매개변수를 제거하려거든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳은 없는 지 확인
- 2. 메서드 선언을 원하는 형태로 바꾼다.
- 3. 기존 메서드 선언을 참조하는 부분을 모두 찾아서 바뀐 형태로 수정
- 4. 테스트한다.

second process(migration)

- 1. 이어지는 추출 단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩토링
- 2. 함수 본문을 새로운 함수로 추출
|__ 새로 만들 함수 이름이 기존 함수와 같다면 검색하기 쉬운 임시 이름을 붙여둔다
- 3. 추출한 함수에 매개변수를 추가해야 한다면 simple process를 따라 추가한다.
- 4. 테스트
- 5. 기존 함수를 인라인 한다.
- 6. 이름을 임시로 붙여뒀다면 함수 선언 바꾸기를 한 번 더 적용해서 원래 이름으로 되돌림
- 7. 테스트

## 6.6 변수 캡슐화 하기

background: 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 좋음. 즉, 데이터 재구성이라는 어려운 작업을 함수 재구성이라는 더 단순한 작업으로 변환하는 것.
데이터를 변경하고 사용하는 코드를 감시할 수 있는 확실한 통로가 돼 주기 때문에 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워넣을 수 있음.
레거시 코드를 다룰 때는 이런 변수를 참조하는 코드를 추가하거나 변경할 때마다 최대한 캡슐화 해야 한다. 그래야 자주 사용하는 데이터에 대한 결합도 상승을 막을 수 있음

process

- 1. 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
- 2. 정적 검사를 수행한다.
- 3. 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나식 바꿀 때마다 테스트한다.
- 4. 변수의 접근 범위를 제한한다.
|__ 변수로의 직접 접근을 막을 수 없을 때도 있다. 그럴 때는 변수 이름을 바꿔서 테스트 해보면 해당 변수를 참조하는 곳을 쉽게 찾아낼 수 있음.
- 5. 테스트
- 6. 변수 값이 레코드라면 레코드 캡슐화하기를 고려


## 6.7 변수 이름 바꾸기

background: 함수 호출 한 번으로 끝나지 않고 영속되는 필드라면 이름에 더 신경써야 함.

process

- 1. 폭넓게 쓰이는 변수라면 변수 캡슐화하기를 고려
- 2. 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서 하나씩 변경
|__ 다른 코드 베이스에서 참조하는 변수는 외부에 공개된 변수이므로 리팩토링 적용 불가
|__ 변수 값이 변하지 않는 다면 다른 이름으로 복제본을 만들어서 하나씩 점진적으로 변경. 바꿀 때마다 테스트
- 3. 테스트 
