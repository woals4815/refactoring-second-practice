# ch7. encapsulation

모듈을 분리하는 가장 중요한 기준은 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 얼마나 잘 숨기는냐에 있음

대표적인 형태인 데이터 구조
- 레코드 캡슐화하기
- 컬렉션 캡슐화하기
- 기본형을 객체로 바꾸기

클래스는 내부 정보 뿐만 아니라 클래스간 연결관계를 숨기는 데도 유용
- 위임 숨기기
- 중개자 제거하기

함수 또한 구현을 캡슐화한다. 

## 7.1 Encapsulate Record

background: 대부분 데이터 레코드를 표현하는 구조를 제공한다. 레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 의미 단위로 전달할 수 있는데 단순한 레코드에는 단점이 있음. 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야 하는 점이 번거로움.

레코드 구조
- 필드 이름을 노출하는 형태
- 필드 외부로 숨겨서 내가 원하는 이름을 쓸 수 있는 형태

process

- 1. 레코드를 담은 변수를 캡슐화한다.
|__ 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽게 지어준다

- 2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다. 
- 3. 테스트
- 4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
- 5. 레코드를 반환하는 예전 함수를 사용하는 코드를 4에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀때마다 테스트
|__ 중첩된 구조처럼 복잡한 레코드라면, 먼저 데이터를 갱신하는 클라에 주의해서 봄. 클라가 데이터를 읽기만 한다면 데이터의 복제본이나 읽기 전용 프락시를 반환할 지 고려해보자.

- 6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다.
- 7. 테스트
- 8. 레코드의 필드도 데이터 구조인 중첩구조라면, 레코드 캡슐화하기와 컬렉션 캡슐화하기 재귀적으로 적용

## 7.2 encapsulate Collection

background: 가장 흔한 방식은 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다. 중요한 점은 코드 베이스에서 일관성을 주는 것.

process

- 1. 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슈로하하기부터 
- 2. 컬렉션에 원소를 추가/제거하는 함수를 추가한다.
|__ 컬렉션 자체를 통째로 바꾸는 세터는 제거한다. 세터를 제거할 수 없다면 인수로 받은 컬렉션을 복제해 저장하도록 만든다.

- 3. 정적 검사를 수행
- 4. 컬렉션을 참조하는 부분을 모두 찾음. 컬렉션의 변경자를 호출하는 코드가 모두 앞에서 추가한 추가/제거 함수를 호출하도록 수정. 하나씩 수정할 때마다 테스트한다.
- 5. 컬렉션 게터를 수정해서 원본 내용을 수정할 수 없는 읽기 전용 프록시나 복제본을 반환
- 6. 테스트

## 7.3 Replace Primitive with Object

background: 나중에 특별한 동작(formating)이 필요해지면 클래스에 추가하면 되니 프로그램이 커질수록 점점 유용한 도구가 된다.

process

- 1. 변수를 먼저 캡슐화
- 2. 단순한 value class를 만든다. 생성자는 기본 값을 인수로 받아서 저장하고, 이 값을 반환하는 게터를 추가한다.
- 3 .정적 검사를 수행
- 4. value class의 인스터스를 새로 만들어서 필드에 저장하도록 세터를 수정한다. 이미 있다면 필드의 타입을 적절히 변경
- 5. 새로 만든 클래스의 게터를 호출한 결과를 반환하도록 게터를 수정한다. 
- 6. 테스트
- 7. 함수이름을 바꾸면 원본 접근자의 동작을 더 잘 드러낼 수 있는 지 검토
|__ 참조를 값으로 바꾸거나 값을 참조로 바꾸면 새로 만든 객체의 역할이 더 잘 드러나는지 검토


## 7.4 Replace Temp with Query

backround: 아예 함수로 만들어 사용하는 편이 나을 때가 많다. 긴 함수의 한 부분을 별도 함수로 추출하고자 할 대 변수들을 각각의 함수로 만들면 일이 수월해진다. 추출한 함수에 변수를 따로 전달할 필요가 없어짐. 이 덕분에 추출한 함수와 원래 함수의 경계가 더 분명해짐. 

process

- 1. 변수가 사용되기 전에 값이 확실히 결정되는 지, 변수를 사용할 때마다 계산 로직이 매번 다른 결과를 내지는 않는 지 확인한다.
- 2. 읽기 전용으로 만들 수 있는 변수는 읽기 전용으로 만든다.
- 3. 테스트 한다.
- 4. 변수 대입문을 함수로 추출한다.
|__ 변수와 함수가 같은 이름을 가질 수 없다면 함수 이름을 임시로 짓는다. + 추출한 함수가 부수 효과를 일으키지 않는지 확인. 부수효과가 있다면 질의 함수와 변경 함수 분리하기로 대처
- 5. 테스트
- 6. 변수 인라인하기로 임시 변수를 제거한다. 

## 7.5 Extract Class

background: 기존 클래스를 굳이 쪼갤 필요까지는 없다고 생각해 새로운 역할을 덧씌우기 쉬운데 그렇게 하면 엄청 복잡해짐

process
- 1. 클래스의 역할을 분리할 방법을 정한다.
- 2. 분리될 역할을 담당할 클래스를 새로 만든다.
|__ 원래 클래스에 남은 역할과 클래스 이름이 어울리지 않는다면 적절히 바꾼다.

- 3. 원래 클래스의 생성자에서 새로운 클래스의 인스턴스를 생성하며 필드에 저장해둔다.
- 4. 분리될 역할에 필요한 필드들을 새 클래스로 옮긴다. 하나씩 옮길 때마다 테스트
- 5. 메서드들도 새 클래스로 옮긴다. 이때 저수준 메서드, 다른 메소드를 호출하기보다는 호출을 당하는 일이 많은 메서드부터 옮긴다. 하나씩 옮기면서 테스트
- 6. 양쪽 클래스의 인터페이스를 살펴보면서 불필요한 메서드를 제거, 이름도 새로운 환경에 맞게 바꾼다.
- 7. 새클래스를 외부로 노출할지 정한다. 노출하려거든 새 클래스에 참조를 값으로 바꾸기를 적용할 지 고민해본다.

## 7.6 Inline Class

background: 클래스 인라인은 클래스 추출하기를 거꾸로 돌리는 리팩터링. 더 이상 제 역알을 못 해서 그대로 두면 안 되는 클래스를 인라인. 주로 역할을 롬기는 리팩터링을하고 특정 클래스에 남은 역할이 거의 없을 때 이런 현상이 자주 발생. 그리고 두 클래스의 기능을 지금과 들게 배분하고 싶을 때로 클래스를 인라인. 

process
- 1. 소스 클래스의 각 public 메서드에 대응하는 메서드들을 타깃 클래스에 생성. 이 메서드들은 단순히 작업을 소스 클래스로 위임해야 함.
- 2. 소스 클래스의 메서드를 사용하는 코드를 모두 타깃 클래스의 위임 메서드를 사용하도록 바꾼다. 하나씩 바꿀 때마다 테스트.
- 3. 소스 클래스의 메서드와 필드를 모두 타깃 클래스로 옮긴다. 하나씩 옮길 때마다 테스트.
- 4. 소스 클래스를 삭제하고 조의를 표한다. 


## 7.7 Hide Delegate


background: 모듈화 설계를 제대로하는 핵심은 캡슐화. 서버 객체의 필드가 가리키는 객체(위임객체)의 메서드를 호출하려면 클라이언트는 이 위임 객체를 알아야 함. 
위임 객체의 인터페이스가 바뀌면 모든 클라이언트가 코드를 수정해야 함. 이러한 의존성을 없애려면 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 됨.

process

- 1. 위임 객체의 각 메서드에 해당하는 위임 메서드를 서버에 생성
- 2. 클라이언트가 위임 객체 대신 서버를 호출하도록 수정한다. 하나씩 테스트
- 3. 모두 수정했으면 서버로부터 위임 객체를 얻는 접근자를 제거한다.
- 4. 테스트


