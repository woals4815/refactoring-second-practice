# ch7. encapsulation

모듈을 분리하는 가장 중요한 기준은 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 얼마나 잘 숨기는냐에 있음

대표적인 형태인 데이터 구조
- 레코드 캡슐화하기
- 컬렉션 캡슐화하기
- 기본형을 객체로 바꾸기

클래스는 내부 정보 뿐만 아니라 클래스간 연결관계를 숨기는 데도 유용
- 위임 숨기기
- 중개자 제거하기

함수 또한 구현을 캡슐화한다. 

## 7.1 Encapsulate Record

background: 대부분 데이터 레코드를 표현하는 구조를 제공한다. 레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 의미 단위로 전달할 수 있는데 단순한 레코드에는 단점이 있음. 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야 하는 점이 번거로움.

레코드 구조
- 필드 이름을 노출하는 형태
- 필드 외부로 숨겨서 내가 원하는 이름을 쓸 수 있는 형태

process

- 1. 레코드를 담은 변수를 캡슐화한다.
|__ 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽게 지어준다

- 2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다. 
- 3. 테스트
- 4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
- 5. 레코드를 반환하는 예전 함수를 사용하는 코드를 4에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀때마다 테스트
|__ 중첩된 구조처럼 복잡한 레코드라면, 먼저 데이터를 갱신하는 클라에 주의해서 봄. 클라가 데이터를 읽기만 한다면 데이터의 복제본이나 읽기 전용 프락시를 반환할 지 고려해보자.

- 6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다.
- 7. 테스트
- 8. 레코드의 필드도 데이터 구조인 중첩구조라면, 레코드 캡슐화하기와 컬렉션 캡슐화하기 재귀적으로 적용

## 7.2 encapsulate Collection

background: 가장 흔한 방식은 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다. 중요한 점은 코드 베이스에서 일관성을 주는 것.

process

- 1. 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슈로하하기부터 
- 2. 컬렉션에 원소를 추가/제거하는 함수를 추가한다.
|__ 컬렉션 자체를 통째로 바꾸는 세터는 제거한다. 세터를 제거할 수 없다면 인수로 받은 컬렉션을 복제해 저장하도록 만든다.

- 3. 정적 검사를 수행
- 4. 컬렉션을 참조하는 부분을 모두 찾음. 컬렉션의 변경자를 호출하는 코드가 모두 앞에서 추가한 추가/제거 함수를 호출하도록 수정. 하나씩 수정할 때마다 테스트한다.
- 5. 컬렉션 게터를 수정해서 원본 내용을 수정할 수 없는 읽기 전용 프록시나 복제본을 반환
- 6. 테스트
